//! The Point Example Pkg

/// `IAdd` interface
interface IAdd {
    //! two items

    /// The type of output
    type Output;

    /// add method
    fn add(self, rhs: Self) -> Self::Output;
}

/// Point type
#[derive(IDebug, ICopy, ICmp)]
pub struct Point {
    //! (x, y)

    /// x coord
    x: int,
    /// y coord
    y: int,
}

extension Point {
    /// create a new point
    #[inline]
    pub fn new(x: int, y: int) -> Self {
        return Self::{x, y};
    }

    /// get x
    #[inline]
    pub fn x(self) -> T {
        return self.x;
    }

    /// get y
    #[inline]
    pub fn y(self) -> T {
        return self.y;
    }

    /// map fn
    pub fn map(self, func: Self -> int) -> int {
        return func(self);
    }

    /// some transform
    pub fn some_transform(self) -> Self {
        let p = unsafe {
            let len = self.map(||sqrt(p.x*p.x + p.y*p.y));
            if(len > 5) {
                break p;
            }
            break Self::{.x=-p.x, .y=-p.y};
        };
        return p;
    }
}

extension Point: IAdd {
    type Output = Self;

    /// implement Point::add method
    fn add(self, rhs: Self) -> Self {
         return Self::{
            .x = self.x() + other.x(),
            .y = self.y() + other.y()
        };
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn new() {
        let p0 = Point::{.x=0, .y=1};
        let p1 = Point::new(0, 1);
        assert(p0 == p1);
    }

    #[test]
    fn map() {
        let p0 = Point::{.x=3, .y=4};
        let r = p0.map(|p| {
            return sqrt(p.x*p.x + p.y*p.y);
        });
        assert(r == 5);
    }
}
